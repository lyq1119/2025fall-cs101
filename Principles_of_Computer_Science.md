# 计算机原理

*Updated 2025-09-25 22:16 GMT+8*  
 *Compiled by Hongfei Yan (2024 Fall)*    



> 我们重点讲解三个计算机原理：1）ASCII编码，2）虚拟地址空间（对于理解操作系统和内存管理至关重要），3）图灵机（对深入理解算法和可计算性有着不可替代的作用）



​	硬件和软件的组合形成可用的计算系统。硬件通常由软件指示以执行任何命令或指令。计算机硬件包括计算机的物理，有形部件或组件，例如主板（Main Board） 、中央处理器（Central Processing Unit, CPU）、显示器、键盘和鼠标。计算机软件包括系统软件和应用软件。系统软件负责管理计算机系统中各种独立的硬件，使得它们可以协调工作。系统软件中常用的操作系统有 Linux、macOS、Unix、Windows等。应用软件是为了某种特定的用途而被开发的软件。常见的应用软件有文字处理、程序设计、网页浏览器、输入法和媒体播放器等。

​	对计算机设计具有重要意义的三个原理是：图灵机、进程的虚拟地址空间和 ASCII 表。

# 1 ASCII 编码

​	计算机外部的各种数据类型（Text, Number, Image, Audio, Video）在存储前，都会转换为统一的表示形式，再存入计算机；输出时再将其还原。这种通用的表示形式称为 **位模式（bit pattern）**。不同数据类型的存储方式如图 1-1 所示。



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20230109195344263.png" alt="image-20230109195344263" style="zoom: 33%;" />

<center>图1-1 不同数据类型的存储（注：图片来源为 Behrouz Forouzan[6]，2008年12月）</center>



​	位（bit）是计算机中最小的数据单位，只能取值 0 或 1，通常用于表示某种状态，例如：1 表示开关接通，0 表示断开。位可以组成序列来表示各种数据，这个由 0 和 1 组成的序列就称为 **位模式**。当位数为 8 时，这个序列被称为 **1 字节（byte）**。

​	接下来我们以**文本（Text）**为例，看看它是如何存储的。
​	在任何语言中，文本由符号组成，而每个符号都可以用一个位模式表示。表示一个符号所需的位数取决于该语言中符号的总数量，如表 1-1 所示。



表1-1 符号数量和位模式长度

| 符号数目 | 位模式的长度 |
| -------- | ------------ |
| 2        | 1            |
| 4        | 2            |
| 8        | 3            |
| 16       | 4            |
| 256      | 8            |
| 65536    | 16           |

​		

​	为了让文本符号与位模式一一对应，人们设计了不同的 **代码表**，这种将符号映射为位模式的过程称为**编码**。	

​	美国国家标准协会（ANSI）发布的 **ASCII（American Standard Code for Information Interchange）** 是最早也是最经典的编码表之一。ASCII 使用 7 位二进制数来表示字符，可表示 2^7^ = 128 种符号，包括 26 个大写字母、26 个小写字母、数字、标点符号以及控制字符等。图 1-2 展示了几个大写字母的二进制位模式表示。



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20230109195420117.png" alt="image-20230109195420117" style="zoom:33%;" />

<center>图1-2 大写字母的二进制位模式表示</center>



​	如果编程语言的注释使用英文，那么 ASCII 中的字符已经足够。
​	需要注意的是，ASCII 的前 32 个代码（0–31）是**控制字符**，用于设备控制而不是打印内容，例如：

- 10：换行（Line Feed）
- 13：回车（Carriage Return）
- 27：转义（Escape）

​	此外，48–57 表示数字 0–9，65–90 表示大写字母 A–Z，97–122 表示小写字母 a–z。只要记住**大写字母的编码在小写字母之前**，就能大致推断出字符对应的十进制值。



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20230109195509129.png" alt="image-20230109195509129" style="zoom: 33%;" />

<center>图1-3 ASCII代码表（注：图片来源为 lookuptables.com。增加了两条横线和三个矩形框，用来突出重点部分）</center>



​	在 Python 中，可以快速查看 ASCII 表：

```python
import string
print(string.printable)
```

​	输出结果为：

```
0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ 	
\r\x0b\x0c
```

​	其中 `string.printable` 返回所有可打印字符（数字、字母、标点和空白符）。如果想查看 `string` 模块中有哪些可用常量和函数，可以使用：

```python
dir(string)
```



​	**ASCII 的结构特性**

- 数字 0–9 的二进制编码统一以 `0011` 开头。
- 大写字母与小写字母的编码在二进制模式上只相差 **一个位**（`00100000`，即 0x20h），这使得大小写转换可以通过简单的位运算实现。

​	例如，将 ASCII 大写字母转换为小写字母，可以“打开”这一位（按位 OR 操作）：

```python
'''
				01000001 = 41h = ASCII upper-case letter 'A'

OR			00100000 = 20h <-- this is the bit we want turned on

				--------

EQUALS	01100001 = 61h = ASCII lower-case letter 'a'
'''
# 'A' 转换为 'a'
uppera = ord('A')
lowera = uppera | 0x20    # bitwise OR with 20h 
print(chr(lowera))  # 输出: a

lowera = uppera  |  (1<<5)
print(chr(lowera))  # 输出: a

# 'a' 转换为 'A'
lowera = ord('a')
uppera = lowera  &  ~0x20    # bitwise AND with 10111111
print(chr(uppera))  # 输出: A

uppera = lowera  &  ~(1<<5)
print(chr(uppera))  # 输出: A
```

​	这种位级操作在大小写搜索、比较等场景中非常高效。	



### 示例：E28674:《黑神话：悟空》之加密

http://cs101.openjudge.cn/pctbook/E28674/

小xu了解后很感兴趣，于是她开始学习了加密解密相关的技术。某一天，她猜测某一段密文只是采用了一种非常简单的加密方法完成加密：每个字母对应的密文是其在字母表中的后 k 个字母，但 **'a' 被视为 'z' 的下一个字母，从而整个字母表形成一个环**。例如，如果 k=3，那么字母 'a' 将被加密为 'd'，'z' 加密为 'c'，依此类推。

现在，请你帮助她按照她的猜测完成对密文的破译（即根据密文得出其对应的明文）。



**输入**

第一行为一个整数 k，表示加密方法中的偏移量。(1 ≤ k ≤ 108000)
第二行为一个由字母组成的字符串 s，表示需要解密的文本。(1 ≤ |s| ≤ 342)

**输出**

密文对应的明文。



```python
characters=[chr(i) for i in range(65,91)]
uporlow=[]  
outstring=''  
  
k=int(input())%26  
instring=input()  
  
for i in instring:  
    if i.isupper():  
        uporlow.append(1)  
    if i.islower():  
        uporlow.append(0)  
instring=instring.upper()  
  
for i in range(len(instring)):  
    place=characters.index(instring[i])-k  
    if uporlow[i]==0:  
        outstring+=characters[place].lower()  
    if uporlow[i]==1:  
        outstring+=characters[place]  
  
print(outstring)

```

靳熙恒 25 物理学院，在黑神话悟空那道题里初始化的字母表本来是手打的，但之后学了ASCII码，于是可以自动生成字母表了，解放双手！之后还学到可以用 string 库生成字母表。



# 2 虚拟地址空间

​	自 20 世纪 40 年代以来，计算机的基础架构已逐渐形成标准，包括处理器、用于存储指令和数据的内存、以及输入输出设备。这一架构通常称为**冯·诺依曼架构**（Von Neumann Architecture），以数学家与计算机科学家约翰·冯·诺依曼（John von Neumann，1903 年 12 月 28 日－1957 年 2 月 8 日）的名字命名。他在 1946 年发表的论文中首次系统描述了这种架构。论文开篇用现代术语来解释，就是：**CPU** 负责算法和控制，**RAM** 与磁盘承担数据与指令存储，而键盘、鼠标、显示器等则与操作人员交互。
​	在这一架构中，与存储相关的进程的**虚拟地址空间**是需要重点理解的部分。

​	**虚拟存储器**（Virtual Memory）是一种抽象机制，它为每个进程提供了一个假象——仿佛自己独占全部主存。实际上，所有进程都看到相同且连续的内存布局，这个抽象的内存视图称为**虚拟地址空间**。
​	如图 1-4 所示，是一个典型 Linux 进程的虚拟地址空间（其他 Unix 系统类似）。在 Linux 中，最高四分之一的地址空间保留给内核代码与数据，这对所有进程都一样；其余四分之三则分配给用户进程的代码与数据。需要注意的是，图中的内存地址是**自下而上递增**的。



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20230109195232404.png" alt="image-20230109195232404" style="zoom:25%;" />

图1-4 进程的虚拟地址空间（Process virtual address space）（注：图片来源为 Randal Bryant[8]，2015年3月）



​	每个进程的虚拟地址空间由一系列功能明确的**区域（area）**构成。按照地址从低到高，大致可以分为以下几个部分：

1. **程序代码与数据（Code and Data）**
   程序代码从固定地址开始，紧接其后的数据区存放全局变量等。它们由可执行文件直接初始化，例如示例程序 `hello` 的可执行文件。
2. **堆（Heap）**
   位于代码和数据区之后，是**运行时堆**（Run-time Heap）。与启动时大小固定的代码与数据区不同，堆的大小可在程序运行过程中动态变化，例如通过 C 标准库函数 `malloc` 和 `free` 来分配或释放内存。
3. **共享库（Shared Libraries）**
   位于地址空间中部，用于存放共享库（如标准 C 库、数学库等）的代码与数据。这一机制允许多个进程共享相同的库文件，从而节省内存并便于更新。
4. **栈（Stack）**
   位于用户虚拟地址空间顶部，用于函数调用与局部变量存储。与堆一样，用户栈（User Stack）在程序执行时可动态扩展或收缩——函数调用时栈增长，函数返回时栈缩小。
5. **内核虚拟存储器（Kernel Virtual Memory）**
   占据地址空间最顶端，存放内核常驻代码和数据。用户程序不能直接访问这一区域，也不能调用内核定义的函数。

​	虚拟存储器的实现依赖于**硬件与操作系统的紧密协作**，包括对处理器生成的每一个地址进行硬件级翻译。核心思想是：将进程的虚拟内存内容保存在磁盘上，并利用主存作为磁盘的高速缓存，从而在保证进程隔离的同时提高访问效率。





> 对写程序重要，能感觉到程序在计算机中哪个位置，为什么出错。
>
> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250105194607858.png" alt="image-20250105194607858" style="zoom:50%;" />



# 3 图灵机

​	艾伦·麦席森·图灵（Alan Mathison Turing，又译阿兰·图灵，1912 年 6 月 23 日－1954 年 6 月 7 日）是计算机科学与人工智能的先驱。1937 年，他首次提出了一种“通用计算设备”的设想：假设所有计算都可以在一种特殊的理想化机器上执行，这就是**图灵机**（Turing Machine）。
​	图灵将模型建立在人类进行计算的思维与步骤之上，并将这些行为抽象成一种用于计算的机械模型。图灵机由两大部分构成（见图 1-5）：

- **存储带（tape）**：一条可以在两个方向上无限延伸的带子，被划分为一个个方格（cell）。每个方格可存储一个来自有限字符集的符号。在实际机器中，磁带的长度虽然有限，但需足够容纳运算所需的全部数据。
- **控制器（controller）**：包含一个可双向移动的**读写头（head）**，能在当前方格上读取或写入符号；机器在任一时刻处于某个**状态（current state）**，状态集合是有限的；机器可加载一份**图灵程序（program）**，该程序由一系列**转换规则（transition rules）**构成，规定了在给定状态和当前符号下，机器应切换到的新状态、写入的符号，以及读写头的移动方向（左、右或不动）。



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20230109195108814.png" alt="image-20230109195108814" style="zoom: 33%;" />

<center>图1-5 由一条存储带和一个控制器构成的图灵机（注：图片来源为 baike.sogou.com，2023年1月)</center>



​	在网站 [aturingmachine.com](http://aturingmachine.com/) 上，Mike Davey 展示了自己制造的一台实体图灵机（见图 1-6），忠实还原了图灵论文中机器的经典外观与操作方式。该机器由微控制器驱动，运行时根据从 SD 卡加载的一组状态转换表，以及磁带上的符号进行运算。
​	需要注意的是，磁带并不仅仅是输入/输出介质或简单的存储器——在某种意义上，磁带本身就是计算机。当读写头按照简单的规则读写磁带上的符号时，计算过程便在其中发生。

​	这台机器的核心是**读写头**：它推动磁带移动，并将目标单元定位到读写位置；然后读取该单元的符号（如有），确定符号类型，并按规则进行写入或状态转换。该实体机一次只处理一个单元的信息。其磁带是一卷长达 1000 英尺的白色 35 毫米胶片，符号“1”和“0”由机器使用黑色笔直接写在胶片上。



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20230109195144878.png" alt="image-20230109195144878" style="zoom: 33%;" />

<center>图1-6  体现图灵机模型的机器（注：图片来源为aturingmachine.com，2022年5月）</center>



​	**软件实现**：提供一个图灵机的 Python 实现，代码在
https://github.com/GMyhf/2019fall-cs101/tree/master/TuringMachine
​	参考自 https://www.python-course.eu/turing_machine.php，在此基础上增加了加法操作，能够完成 14 分钟示例视频中的加法演示。该实现采用 Python **面向对象编程（Object-Oriented Programming, OOP）** 方式编写，相关语法可参考 https://www.runoob.com/python3/python3-class.html。

​	**视频参考**：

- 图灵机的构成（6 分钟讲解）：https://www.bilibili.com/video/BV12B4y1X7QV
- 图灵机的原理与示例（14 分钟讲解）：https://www.bilibili.com/video/BV13v4y1w7yM



## 其他知识点4～6、7和8

下面内容中，“4 进制转换”～“6 数据运算”的内容，取自《计算机科学导论》，佛罗赞，2018年1月第4版。



# 4 进制转换

**位置化数字系统**中，在数字中符号所占据的位置决定了其表示的值。

表4-1是四种位置化系统（十进制、二进制、八进制和十六进制）的小结。

表4-2 显示了数字15在十进制中使用2个数码，在二进制中使用4个数码，在八进制中使用2个数码，在十六进制中仅仅使用1个数码。十六进制表示法显然是最短的。



表4-1 4种位置化系统的小结

| 系统     | 底   | 符号                                           | 例子            |
| -------- | ---- | ---------------------------------------------- | --------------- |
| 十进制   | 10   | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9                   | 2345.56         |
| 二进制   | 2    | 0, 1                                           | $(1001.11)_2$   |
| 八进制   | 8    | 0, 1, 2, 3, 4, 5, 6, 7                         | $(156.23)_8$    |
| 十六进制 | 16   | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F | $(A2C.A1)_{16}$ |



表4-2 4种位置化系统中的数字比较

| 十进制 | 二进制 | 八进制 | 十六进制 | 十进制 | 二进制 | 八进制 | 十六进制 |
| ------ | ------ | ------ | -------- | ------ | ------ | ------ | -------- |
| 0      | 0      | 0      | 0        | 8      | 1000   | 10     | 8        |
| 1      | 1      | 1      | 1        | 9      | 1001   | 11     | 9        |
| 2      | 10     | 2      | 2        | 10     | 1010   | 12     | A        |
| 3      | 11     | 3      | 3        | 11     | 1011   | 13     | B        |
| 4      | 100    | 4      | 4        | 12     | 1100   | 14     | C        |
| 5      | 101    | 5      | 5        | 13     | 1101   | 15     | D        |
| 6      | 110    | 6      | 6        | 14     | 1110   | 16     | E        |
| 7      | 111    | 7      | 7        | 15     | 1111   | 17     | F        |



在十进制系统中，底 `b=10` 并且用10个符号来表示一个数。该系统中的符号常被称为十进制数码或仅称为数码。

在二进制系统中，底 `b=2` 并且用2个符号来表示一个数。该系统中的符号常被称为二进制数码或位。

在十六进制系统中，底 `b=16` 并且用16个符号来表示一个数。该系统中的符号常被称为十六进制数码。

在八进制系统中，底 `b=8` 并且用8个符号来表示一个数。该系统中的符号常被称为八进制数码。

可以从任意底转换到十进制。将数码乘以其在源系统中的位置量并求和便得到在十进制中的数。

能够将十进制数转换到与其等值的任意底。需要两个过程：一是用于整数部分，另一个是用于小数部分。<mark>整数部分需要连除，而小数部分需要连乘</mark>。

将数字从二进制转换到十六进制很容易，反之亦然。这是因为<mark>二进制中的4位恰好是十六进制中的1位</mark>。

将数字从二进制转换到八进制很容易，反之亦然。这是因为<mark>二进制中的3位恰好是八进制中的1位</mark>。



## 4.1 十进制-二进制

**例2-14** 将十进制数0.625转换为二进制数。

解 因为0.625没有整数部分，该例子显示小数部分如何计算。这里是以2为底。在左边一角写上这个十进制数。连续乘2，并记录结果的整数和小数部分。小数部分移到右边，整数部分写在每次运算的下面。当小数部分为0，或达到足够的位数时结束。结果是0.625 = (0.101)₂。

```
十进制    0.625 → 0.25 → 0.50 → 0.00
					↓       ↓       ↓  
二进制  .  1       0       1
```



**例2-15** 下面演示如何将0.634转换为八进制数且精确到小数4位。结果是0.634 = (0.5044)₈。

```
十进制    0.634 → 0.072 → 0.576 → 0.608 → 0.864
					↓       ↓       ↓       ↓
八进制  .  5       0       4       4
```



**例2-16** 下面演示如何将十进制数178.6转换为十六进制数，且精确到1位小数。结果是178.6 = (B2.9)₁₆。注意，以16为底时除或乘以16。

```
十进制    0 ← 11 ← 178    0.6 → 0.6
						 ↓     ↓       ↓
十六进制    	B     2   .   9
```



**例2-17** 把小的十进制数（通常小于256）转换为二进制数有一个变通的方法，即把这个数分解为下列二进制位置量对应数的和。

```
位置量    			2⁷   2⁶  2⁵  2⁴  2³  2²  2¹  2⁰
十进制对等量    128  64  32  16  8   4   2   1
```

使用该表可以转换165为二进制数(10100101)₂，如下所示：

```
十进制 165 = 128 + 0 + 32 + 0 + 0 + 4 + 0 + 1
二进制    			1   0   1    0   0   1   0   1
```



**例2-18** 当分母是2的幂次时，用类似的方法可以把十进制数小数转换为二进制。

```
位置量    		2⁻¹  2⁻²  2⁻³  2⁻⁴  2⁻⁵  2⁻⁶  2⁻⁷
十进制对等量  1/2  1/4  1/8  1/16 1/32 1/64 1/128
```

使用该表可以转换27/64为二进制数(0.011011)₂，如下所示：

```
十进制 27/64 = 16/64 + 8/64 + 2/64 + 1/64
              1/4   + 1/8   + 1/32 + 1/64
```

根据十进制对等的值排列这些分数:

```
十进制 27/64 =	0	+	1/4 + 1/8 + 0	+	1/32 + 1/64
二进制					0   	1		  1   0   	1      1
```



## 4.2 二进制-十六进制

我们能轻松将数字从二进制转换到十六进制，反之亦然。这是因为在这两个进制之间存在一种关系：二进制中的4位恰好是十六进制中的1位。



**例2-19** 下面演示如何将二进制数$(10011100010)_2$转换为十六进制数。

**解** 我们先将二进制数排为4位一组的形式：100 1110 0010。注意最左边一组可能是1到4位不等。我们根据表2-2所示的值对照每组等量转换得到十六进制数$(4E2)_{16}$。



**例2-20** 与十六进制数$(24C)_{16}$相等的二进制数是多少？

**解** 将每个十六进制数码转换成4位一组的二进制数：2→0010，4→0100，以及C→1100。该结果是$(001001001100)_2$。

> 在二进制表示中，前面的零（即前导零）是可以去掉的，因为它们并不改变数值的大小。如果题目明确问内存中的表示形式，不能去掉前导零。



## 4.3 二进制-八进制

**例2-21** 下面演示如何将二进制数$(101110010)_2$转换为八进制数。

**解** 每3位一组转换为1位八进制数码。根据表2-2所示的值对照每3位一组等量转换得到八进制数结果是$(562)_8$。



**例2-22** 与$(24)_8$相等的二进制数是多少？

**解** 将每个八进制数码写成对等的二进制位组，得到$(010100)_2$。



## 4.4 八进制-十六进制

将数字从八进制转换到十六进制并不难，反之亦然。可以使用二进制系统作为中介系统。

该步骤如下：

- 从八进制转到十六进制，先将八进制转到二进制。将位数重排成4位一组，找到十六进制的对等值。

- 从十六进制转到八进制，先将十六进制转到二进制。将位数重排成3位一组，找到八进制的对等值。



# 5 数据存储

## 5.1 计算机内部的数据

所有计算机外部的数据类型的数据都采用统一的数据表示法转换后存入计算机中，当数据从计算机输出时再还原回来。这种通用的格式称为位模式。

**1. 位**

位（bit, binary digit的缩写）是存储在计算机中的最小单位，它是0或1。位代表设备的某一状态，这些设备只能处于两种状态之一。例如，开关要么合上要么断开。用1表示合上状态，0表示断开状态。电子开关就表示一个位。换句话说，一个开关能存储一个位的信息。今天，计算机使用各种各样的双态设备来存储数据。

**2. 位模式**

为了表示数据的不同类型，应该使用位模式，它是一个序列，有时也称为位流。图3-2展示了由16个位组成的位模式。它是0和1的组合。这就意味着，如果我们需要存储一个由16个位组成的位模式，那么需要16个电子开关。如果我们需要存储1000个位模式，每个16位，那么需要16 000个开关。通常长度为8的位模式被称为1个字节（byte）。有时用字（word）这个术语指代更长的位模式。



> **存储数字**
>
> 在存储到计算机内存中之前，数字被转换为二进制系统。但是，这里还有两个问题需要解决：
>
> 1) 如何存储数字的符号。
> 2) 如何显示十进制小数点。
>
> 有多种方法可处理符号问题，本章后面陆续讨论。对于小数点，计算机使用两种不同的表示方法：<mark>定点和浮点</mark>。第一种用于把数字作为整数存储——没有小数部分，第二种把数字作为实数存储——带有小数部分。

## 5.2 存储整数

整数是完整的数字（即没有小数部分）。例如，134和-125是整数而134.23和-0.235则不是。整数可以被当作小数点位置固定的数字：小数点固定在最右边。因此，定点表示法用于存储整数。在这种表示法中，小数点是假定的，但并不存储。

但是，用户（或程序）可能将整数作为小数部分为0的实数存储。这是可能发生的，例如，整数太大以至于无法定义为整数来存储。为了更有效地利用计算机内存，无符号和有符号的整数在计算机中存储方式是不同的。

**整数通常使用定点表示法存储在内存中。**

### 5.2.1 无符号表示法

无符号整数就是没有符号的整数。它的范围介于0到无穷大之间。然而，由于计算机不可能表示这个范围的所有整数，通常，计算机都定义了一个最大无符号整数的常量，称为最大无符号整数，它的值是 \((2^n - 1)\)。这里 \(n\) 就是计算机中分配用于表示无符号整数的二进制位数。

**(1) 存储无符号整数**

使用以下步骤输入存储无符号整数：

- 首先将整数变成二进制数。
- 如果二进制位数不足 \(n\) 位，则在二进制整数的左边补0，使它的总位数为 \(n\) 位。如果位数大于 \(n\)，该整数无法存储。导致溢出的情况发生，我们后面要讨论这方面内容。



**例5-1** 将7存储在8位存储单元中。

解 首先将整数转换为二进制数 $(111)_2$。加5个0使总的位数为8位，即 $(00000111)_2$。再将该整数保存在存储单元中。注意，右下角的2用于强调该整数是二进制的，并不存储在计算机中。

​		把7变为二进制	→ 		1 1 1

​		在左边加5位    	→ 0 0 0 0 0 1 1 1



**例5-2** 将258存储在16位存储单元中。

解 首先把整数转换为二进制 $(100000010)_2$，加7个0使总的位数满足16位的要求，即得到 $(0000000100000010)_2$。再将该整数被存储在存储单元中。

​		把258变为二进制 → 			1 0 0 0 0 0 0 0 1 0

​		在左边加7位 	→   0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0



**(2) 译解无符号整数**

输出设备译解内存中位模式的位串并转换为一个十进制的无符号整数。



**例5-3** 当译解作为无符号整数保存在内存中的位串00101011时，从输出设备返回什么？

解 使用第2章的解题过程，二进制整数转换为十进制无符号整数43。



**(3) 溢出**

因为大小（即存储单元的位的数量）的限制，可以表达的整数范围是有限的。在n位存储单元中，我们可以存储的无符号整数仅为0到$2^n - 1$之间。



### 5.2.2 二进制补码表示法

几乎所有的计算机都使用二进制补码表示法来存储位于n位存储单元中的有符号整数。这一方法中，无符号整数的有效范围（0到 $2^n - 1$）被分为2个相等的子范围。第一个子范围用来表示非负整数，第2个子范围用于表示负整数。例如，如果n是4，该范围是0000到1111。这个范围分为两半：0000到0111以及1000到1111。

尽管整数的符号影响二进制整数存储时的每一位，但是首位（最左位）决定符号。如果最左位是0，该整数非负；如果最左位是1，该整数是负数。

**在二进制补码表示法中，最左位决定符号。如果它是0，该整数为正，如果是1，该整数为负。**

**(1) 两种运算 Two operations **

在深入讨论这种表示法之前，我们需要介绍两种运算。第一种称为<mark>反码</mark>或取一个整数的反码。该运算可以应用到任何整数，无论是正的还是负的。该运算简单反转各个位，即把0位变为1位，把1位变为0位。

**例5-8** 下面显示如何取整数00110110的反码。

​	原来的模式：	0 0 1 1 0 1 1 0

​	进行反码运算：    1 1 0 0 1 0 0 1



**例5-9** 下面显示如果进行2次反码运算，就可以得到原先的整数。

​	原来的模式：	  0 0 1 1 0 1 1 0

​	进行1次反码运算：1 1 0 0 1 0 0 1

​	进行2次反码运算：0 0 1 1 0 1 1 0





第2种运算称为二进制中的<mark>补码</mark>或取一个整数的补码。该运算分为两步：首先，从右边复制位，直到有1被复制；接着，反转其余的位。



**例5-10** 下面显示如何取整数00110100的补码。

​	原来的模式：	  0 0 1 1 0 1 0 0

​	进行1次补码运算：1 1 0 0 1 1 0 0

> 目前讲的是补码的运算，还没有到二进制存储，所以暂时不考虑正负，只考虑运算。



**例5-11** 下面显示我们如果进行2次补码运算，就可以得到原先的整数。

​	原来的模式：	  0 0 1 1 0 1 0 0

​	进行1次补码运算：1 1 0 0 1 1 0 0

​	进行2次补码运算：0 0 1 1 0 1 0 0

另一种<mark>将一个整数进行补码运算的方法是先对它进行1次反码运算再加上1得到结果</mark>



**(2) 以二进制补码格式存储整数Storing an integer in two’s complement format**

以二进制补码格式存储整数，计算机遵循以下步骤：

- 将整数变成n位的二进制数。

- 如果整数是正数或零，以其原样存储；<mark>如果是负数，计算机取其补码存储。</mark>


> 正数的补码和其原码相同；负数的补码是它的原码除符号位外逐位取反(即0变1，1变0)，最后在末位加1。
>
> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250105230125177.png" alt="image-20250105230125177" style="zoom: 33%;" />

> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250105230201883.png" alt="image-20250105230201883" style="zoom:50%;" />



**(3) 从二进制补码格式还原整数**Retrieving an integer in two’s complement format

从二进制补码格式还原整数，计算机遵循以下步骤：

- 如果最左位是1，计算机取其补码。如果最左位是0，计算机不进行操作。
- 计算机将该整数转换为十进制。







**例5-12** 用二进制补码表示法将整数 28 存储在 8 位存储单元中。

解 该整数是正数（无符号意思是正的），因此在把该整数从十进制转换成二进制后不再需要其他操作。注意，5个多余的零加到该整数的左边使其成为8位。

​	把28变为8位的二进制：0 0 0 1 1 1 0 0



**例5-13** 用二进制补码表示法将整数 -28 存储在 8 位存储单元中。

解 该整数是负数，因此在转换成二进制后计算机对其进行二进制补码运算。

​	把28变为8位的二进制：0 0 0 1 1 1 0 0

​	进行补码运算：	      1 1 1 0 0 1 0 0



**例5-14** 用二进制补码表示法将存储在 8 位存储单元中的 00001101 还原成整数。

解 最左位是0，因此符号为正。该整数需要转换为十进制并加上符号即可。



## 5.3 存储实数

**实数**是带有整数部分和小数部分的数字。例如：23.7是一个实数（整数部分是23而小数部分是7/10）。尽管固定小数点的表示法可用于表示实数，但结果不一定精确或达不到需要的精度。以下两个例子说明了原因。



**例5-16** 在十进制系统中，假定用一种小数点右边2个数码，左边14个数码，总共16个数码的定点表示法。那么如果试图表示十进制数1.002 34，该系统的实数精度就会受损。该系统把这个数字存储为1.00。



**例5-17** 在十进制系统中，假定用一种小数点右边6个数码，左边10个数码，总共16个数码的定点表示法。那么如果试图表示十进制数236 154 302 345.00，该系统的实数精度就会受损。该系统把这个数字存储为6 154 302 345.00。整数部分比实际小了很多。

**带有很大的整数部分或很小的小数部分的实数不应该用定点表示法存储。**



### 5.3.1 浮点表示法

用于维持正确度或精度的解决方法是使用<mark>浮点表示法</mark>。该表示法允许小数点浮动：我们可以在小数点的左右有不同数量的数码。使用这种方法极大地增加了可存储的实数范围：带有很大的整数部分或很小的小数部分的实数可以存储在内存中。在浮点表示法中，无论十进制还是二进制，一个数字都由3部分组成。

​	符号	位移量	定点数	

第一部分是符号，可正可负。第二部分显示小数点应该左右移动构成实际数字的位移量。第三部分是小数点位置固定的定点表示法。



**一个数字的浮点表示法由3部分组成：符号、位移量和定点数。**



浮点表示法在科学中用于表示很小或很大的十进制数。在称作科学记数法的表示法中，定点部分在小数点左边只有1个数码而且位移量是10的幂次。



**例5-18** 下面演示用科学记数法(浮点表示法)表示的十进制数7 425 000 000 000 000 000 000.00。

解

​	实际数字 → + 7 425 000 000 000 000 000 000.00

​	科学记数法 → + 7.425 × $10^{21}$

这三部分为符号 (+)、位移量 (21) 以及定点部分 (7.425)。注意那个位移量就是指数。这种表示法的好处显而易见。即使在一张纸上写数字，科学记数法也是更短并更省空间。这种记数法使用了浮点表示法的概念，因为那个靠近例题右下方的小数点位置已经向左移了21位形成该数字的定点部分。一些程序设计语言和计算器按照 +7.425E21来显示该数字，因为以10为底是不言而喻的。



**例5-19** 用科学记数法表示数字-0.000 000 000 000 023 2。

解 使用前例同样的方法，将小数点移到数码2之后，如下所示：

​	实际数字 	→ - 0.000 000 000 000 023 2

​	科学记数法     → - 2.32 × $10^{-14}$

注意这里指数是负的，因为小数点需要左移（14位）来构成原数字。我们可再次说该记数法中的数字由3部分组成：符号（-）、实数（2.32）以及负整数（-14）。一些程序设计语言和计算器按照-2.32E-14来显示该数字。



<mark>类似方法可用于表示很小或很大的存储于计算机中的二进制数字（整数和实数皆可）。</mark>

**例5-20** 用浮点格式表示数字$(101001000000000000000000000000000.00)_2$。

解 使用前例同样的方法，小数点前只保留一位数字，如下所示：

​	实际数字 	→ + $(101001000000000000000000000000000.00)_2$

​	科学记数法     → + 1.01001 × $2^{32}$

注意我们不必担心从最右边的1开始的右侧的那些0，这是因为当我们使用实数 $(1.01001)_2$时它们并不重要。指数显示为32，但它实际上以二进制存储在计算机中。我们也已经显示符号为正，但它可能作为1位存储。



**例5-21** 用浮点格式表示数字$-(0.00000000000000000000000101)_2$。

解 使用前例同样的方法，小数点左边只留一个非零数码：

​	实际数字 	→ $- (0.00000000000000000000000101)_2$

​	科学记数法.    → $- 1.01 × 2^{-24}$

注意指数作为负的二进制数存储在计算机中。



### 5.3.1 规范化

为了使表示法的固定部分统一，科学记数法（用于十进制）和浮点表示法（用于二进制）都在小数点左边使用了唯一的非零数码，这称为规范化。十进制系统中的数码可能是1到9，而二进制系统中该数码是1。在下面，d是非零数码，x是一个数码，y是0或1。

​	十进制 → ± d.xxxxxxxxxxxxxxx 注意：d是1到9，每个x是0到9

​	二进制 → ± 1.yyyyyyyyyyyy 注意：每个y是0或1



### 5.3.3 符号、指数和尾数

在一个二进制数规范化之后，我们只存储了该数的3部分信息：符号、指数和尾数（小数点右边的位）。

例如，+1000111.0101规范化后变成为：

​	$+\quad \quad 2^6 \quad \times \quad 1.0001110101 $

​	$+\quad \quad 6 \quad \quad \quad \quad 0001110101 $

​	$
\begin{array}{ccc}
\uparrow & \uparrow & & \uparrow \\
\text{符号} & \text{指数} & & \text{尾数}
\end{array}
​	$

**注意小数点和定点部分左边的位1并没有存储，它们是隐含的。**

(1) 符号

一个数的符号可以用一个二进制位来存储（0或1）。

(2) 指数

指数（2的幂）定义为小数点移动的位数。注意幂可以为正也可以为负。余码表示法（后面讨论）是用来存储指数位的方法。

(3) 尾数

尾数是指小数点右边的二进制数。它定义了该数的精度。尾数是作为无符号整数存储的。如果我们把尾数和符号一起考虑，则可以说这个组合是作为符号加绝对值格式的整数存储的。但是，我们需要记住它不是整数，而是像整数那样存储的小数部分。我们强调这一点是因为在尾数中如果在数字的右边插入多余的零，这个值将会改变，而在一个真正的整数中，如果在数字的左边插入多余的零，这个值是不会改变的。

**尾数是带符号的小数部分，可以像以符号加绝对值表示法存储的整数那样对待。**



电气和电子工程师协会(IEEE)已定义了几种存储浮点数的标准。这里我们讨论其中两种最常用的--单精度和双精度。



# 6 数据运算

计算机中存储不同类型的数据。本章讲述如何在这些存储在计算机中的数据上进行计算。数据的运算可以分为三大类：算术运行、移位运算和逻辑运算。

## 6.1 逻辑运算

计算机中的数据是以位模式（bit pattern）存储的。逻辑运算是指那些应用于模式中的一个二进制位，或在两个模式中相应的两个二进制位的相同基本运算。这意味着我们可以在位层次上和模式层次上定义逻辑运算。模式层次上的逻辑运算是具有相同类型的位层次上的`n`个逻辑运算，这里的`n`就是模式中的位的数目。

### 6.1.1 位层次上的逻辑运算

一个位可能是0或1，可以假设“0”代表逻辑“假"，而“1”代表逻辑“真”。我们可以应用布尔代数中定义的运算去操纵二进制位。为纪念乔治·布尔（George Boole）而命名的布尔代数属于逻样的特殊数学领域。我们将简单介绍4种被用来操纵二进制位的位层次上的运算：非（NOT)、与（AND）或（OR）和异或（XOR）。

> 非（NOT）
>
> | x    | NOT x |
> | ---- | ----- |
> | 0    | 1     |
> | 1    | 0     |
>
> 与（AND）
>
> | x    | y    | x AND y |
> | ---- | ---- | ------- |
> | 0    | 0    | 0       |
> | 0    | 1    | 0       |
> | 1    | 0    | 0       |
> | 1    | 1    | 1       |
>
> 或（OR）
>
> | x    | y    | x OR y |
> | ---- | ---- | ------ |
> | 0    | 0    | 0      |
> | 0    | 1    | 1      |
> | 1    | 0    | 1      |
> | 1    | 1    | 1      |
>
> 异或（XOR）
>
> | x    | y    | x XOR y |
> | ---- | ---- | ------- |
> | 0    | 0    | 0       |
> | 0    | 1    | 1       |
> | 1    | 0    | 1       |
> | 1    | 1    | 0       |
>
> 



图6-1显示了这4种位层次上运算的符号及其真值表。真值表定义了对于每一种可能的输人或输出值。注意每个运算符的输出总是一位，但输入可以是一位或两位。

**1.非（NOT）**

**NOT运算符**是一元操作符：它只有一个输入。输出位是输人位的相反，如果输入是0，则输出为1;如果输入为1，则输出为0。换言之，NOT运算符是输入的反转。NOT运算符的真值表只有两行，因为单个输入只有两种可能：0或1。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913133342403.png" alt="image-20250913133342403" style="zoom: 67%;" />

<center>图6-1 位层次上的逻辑运算</center>



**2.与(AND)**

**AND运算符**是二元运算符：它有两个输人。如果输入都是1，则输出为1，而在其他三种情况下，输出都是0。AND运算符的真值表有4行，因为两个输入有4种可能的输入组合。AND运算符有趣的一点是:如果输入中有一位是0，则不需要检查其他输入的相应的位便可迅速得到结果为0。

对于 $x = 0 $ 或 $ 1 $，$ x \text{ AND } 0 \rightarrow 0 $ 和 $ 0 \text{ AND } x \rightarrow 0 $。

**3. 或 (OR)**

OR运算符也是二元运算符：它有两个输入。如果输入都是0，则输出为0，而在其他三种情况下，输出都是1。OR运算符的真值表也有4行。OR运算符有时被称为包含或运算符，因为输出值为1时，不但有其中一个输入为1，而且还有当两个输入都是1。这与我们下面要介绍的运算符相对照。

OR运算符有趣的一点是：如果输入中有一位是1，则不需要检查其他输入的相应的位，便可迅速得到结果为1。当我们讨论此运算符在模式层次上的应用时，我们将用到这个特性。

对于 $x = 0 $ 或 $ 1 $，$ x \text{ OR } 1 \rightarrow 1 $ 和 $ 1 \text{ OR } x \rightarrow 1 $。

**4. 异或 (XOR)**

像或运算符一样，XOR运算符（发音为“exclusive-or”）也是二元运算符，只是有一点不同：如果输入都是1，则输出为0。我们能用另一种方式来看这个运算符：当输入相同时，则输出为0；当输入不同时，则输出为1。

**例6-1** 在英语中，我们使用连词“或”时，有时意思是包含或，有时意思却是异或。
a. 句子“I wish to have a car or a house”使用的“or”就是包含或的意思，我希望有一辆车，一栋房子，或二者兼而有之。
b. 句子“Today is either Monday or Tuesday”使用的“or”就是异或的意思，今天不是星期一就是星期二，但不能两个都是。

**例6-2** XOR运算符其实不是新的运算符，我们能用其他三个运算符来模拟它。下面两个表达式是等价的。
$ x \text{ XOR } y \leftrightarrow [x \text{ AND } (\text{NOT } y)] \text{ OR } [(\text{NOT } x) \text{ AND } y] $

如果我们给出两个表达式的真值表，等价就可以得到证明。

XOR 的特性是：如果输入中的一位是1，那结果就是与其他输入中相应位相反。当我们讨论此运算符在模式层次上的应用时，我们将用到这个特性。

对于 $ x = 0 $ 或 $ 1 $，$ x \text{ XOR } 1 \rightarrow \text{NOT } x $ 和 $ x \text{ XOR } 1 \rightarrow \text{NOT } x $。



### 6.1.2 模式层次上的逻辑运算

相同的4个运算符（NOT、AND、OR和XOR）可以被应用到n位模式。效果就是对NOT运算来说，把每个运算符应用于每个位；对于其他3个运算符就是把每个运算符应用于相应的位对。图6-2显示了带输入和输出模式的4个运算符。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913133636588.png" alt="image-20250913133636588" style="zoom:67%;" />

<center>图6-2 应用于位模式的逻辑运算</center>



**例6-3 用NOT（非）运算符来计算位模式10011000**

**解** 结果显示如下，注意NOT运算符把每个0变成1，把每个1变成0。

```
    NOT   1 0 0 1 1 0 0 0	输入
         	0 1 1 0 0 1 1 1	输出
```



**例6-4 用AND（与）运算符来计算位模式10011000和00101010**

**解** 结果显示如下，注意只有输入中相应的位都为1，输出中的位才为1。

```
    AND   1 0 0 1 1 0 0 0	输入1
          0 0 1 0 1 0 1 0	输入2
          0 0 0 0 1 0 0 0	输出
```



**例6-5 对位模式数值10011001和00101110应用或（OR）运算**

**解** 结果显示如下，注意只有输入中相应的位都为0，输出中的位才为0。

```
    OR    1 0 0 1 1 0 0 1	输入1
          0 0 1 0 1 1 1 0	输入2
          1 0 1 1 1 1 1 1	输出
```



**例6-6 使用XOR（异或）运算符对10011001和00101110位运算**

**解** 结果显示如下，注意该例中只有输入中相应的位都为0，输出中的位才为0。

```
    XOR   1 0 0 1 1 0 0 1	输入1
          0 0 1 0 1 1 1 0	输入2
          1 0 1 1 0 1 1 1	输出
```



应用

**4种逻辑运算可用于修改位模式**

**（1）求反**

NOT运算符的唯一应用就是对整个模式求反。对模式应用此运算符把每个0变成1，把每个1变成0。例6-3显示了求反的效果。



**（2）使指定的位复位**

与运算的一个应用就是把一个位模式的指定位**复位（置0）**。这种情况下，第二个输入称为**掩码**。掩码中的0位对第一个输入中相应的位进行复位。掩码中的1位使得第一个输入中相应的位保持不变。这是由AND运算符的特性决定的：如果输入中有一个是0，不管其他输入是什么，输出都是0。模式中的复位有许多应用，例如，如果一个图像使用的是每像素只有一位（黑白图像），那么我们能使用掩码和AND运算符使指定像素变黑。



**例6-7 使用掩码复位模式的最左5位。用模式10100110测试掩码。**

解 掩码是00000111，应用掩码的结果是：

```
    	    1 0 1 0 0 1 1 0	输入
     AND  0 0 0 0 0 1 1 1	掩码
          0 0 0 0 0 1 1 0	输出
```

注意最右边的3位保持不变，而最左边5位，不管它们先前的值是什么，都被复位（变为0）。



**（3）对指定的位置位**

或运算的一个应用是把一个位模式的指定位**置位（置1）**。我们再次使用掩码，但是一个不同的掩码。掩码中的1位对第一个输入中相应的位进行置位，而掩码中的0位使第一个输入中相应的位保持不变。这是由OR操作符的特性决定的：如果一个输入为1，不管其他输入是什么，输出都将是1。模式中的位置位有许多应用，例如，如果一个图像使用的是每像素只有一位（黑白图像），那么我们能使用掩码和OR运算符使指定像素变白。

**例6-8 使用掩码把一个位模式的最左5位置位。使用10100110测试这个掩码。**

解 此掩码为11111000。应用此掩码的结果为：

```
          1 0 1 0 0 1 1 0	输入
    OR    1 1 1 1 1 0 0 0	掩码
          1 1 1 1 1 1 1 0	输出
```

**（4）使指定的位反转**

异或运算的一个应用是使指定的位**反转**，我们再次使用掩码，但是一个不同的掩码。掩码中的1位对第一个输入中相应的位进行反转，而掩码中的0位使第一个输入中相应的位保持不变。这是由XOR操作符的特性决定的：如果一个输入为1，输出与相应的位相反。注意NOT运算符和XOR运算符间的区别。NOT运算符是将输入中所有的位求反，而XOR运算符只是对第一个输入中指定的位求反，正如掩码中所定义的。

**例6-9 用掩码来反转一个模式的最左边5位。用模式10100110检验掩码。**

解 掩码为11111000。运用掩码后的结果为：

```
          1 0 1 0 0 1 1 0	输入
    XOR   1 1 1 1 1 0 0 0	掩码
          0 1 0 1 1 1 1 0	输出
```



## 6.2 移位运算

移位运算移动模式中的位，改变位的位置。它们能向左或向右移动位。我们可以把移位运算分成两大类：逻辑移位运算和算术移位运算。

### 6.2.1 逻辑移位运算

逻辑移位运算应用于不带符号位的数的模式。原因是这些移位运算可能会改变数的符号，此符号是由模式中最左位定义的。我们区分两类逻辑移位运算，如下面描述。

**1. 逻辑移位**

逻辑右移运算把每一位向右移动一个位置。在n位模式中，最右位被丢弃，最左位填0。逻辑左移运算把每一位向左移动一个位置。在n位模式中，最左位被丢弃，最右位填0。图6-3显示了对一个8位模式的逻辑右移和逻辑左移。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913134339208.png" alt="image-20250913134339208" style="zoom:67%;" />

<center>图6-3 逻辑移位运算<center>



**例6-10 对位模式10011000使用逻辑左移运算。**

解 如下所示，最左位被丢弃，0作为最右位被插入。

```
    1 0 0 1 1 0 0 0  原始的
    0 0 1 1 0 0 0 0  移位后
```



**2. 循环移位**

循环移位运算（旋转运算）对位进行移位，但没有位被丢弃或增加。循环右移（或右旋转）把每一位向右移动一个位置，最右位被回环，成为最左位。循环左移（或左旋转）把每一位向左移动一个位置，最左位被回环，成为最右位。图6-4显示了循环左移和循环右移运算。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913134704273.png" alt="image-20250913134704273" style="zoom:67%;" />

<center>6-4 循环移位运算</center>



**例6-11** 对位模式10011000使用循环左移运算。

解 解如下所示，最左位被回环，成为最右位。

```
    1 0 0 1 1 0 0 0   原始的
    0 0 1 1 0 0 0 1  	移位后
```



**例6-12** 逻辑运算和逻辑移位运算给我们提供了操纵位模式的工具。假设有一个模式，在判断过程中需要使用此模式的第三位（从右起），需要知道这特殊的位是0或1.下面显示了如何找出这位。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913135207210.png" alt="image-20250913135207210" style="zoom:67%;" />

我们先对模式进行两次右移，这样目标位被移到最右的位置。然后通过最右位为1其余为0的掩码和AND运算就能得出结果。结果是有7个0，目标位在最右位置的模式。然后可以测试结果：如果它是无符号的整数1，那么目标位就是1；而如果结果是无符号的整数0，那么目标位就是 0。



### 6.2.2 算术移位运算

算术移位运算假定位模式是用二进制补码格式表示的带符号位的整数。算术右移被用来对整数除以2；而算术左移被用来对整数乘以2。这些运算不应该改变符号位（最左）。算术右移保留符号位，但同时也把它复制，放入相邻的右边的位中，因此符号被保存。算术左移丢弃符号位，接受它的右边的位作为符号位。如果新的符号位与原先的相同，那么运算成功，否则发生上溢或下溢，结果是非法的。图6-5显示了这两种运算。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913135349416.png" alt="image-20250913135349416" style="zoom:67%;" />

<center>图6-5 算术移位运算<center>



**例 6-13**对位模式10011001使用算术右移，模式是二进制补码格式的整数。

解 如下所示，最左位被保留，被复制到相邻的右边的位（黑色背景中的白字）中。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913135932420.png" alt="image-20250913135932420" style="zoom:67%;" />

原始数是 -103，新的数是-52，它是-103被除以2并取整的结果。

**例 6-14**对位模式 11011001使用算术左移，模式是二进制补码格式的整数。

解 如下所示，最左位被丢弃，0作为最右位被插人。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913135951388.png" alt="image-20250913135951388" style="zoom:67%;" />

原始数是 -39，新的数是-78，原始数被乘以2。因为没有下溢的发生，所以运算合法。

**例4-15**对位模式 01111111使用算术左移，模式是二进制补码格式的整数。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913140012559.png" alt="image-20250913140012559" style="zoom:67%;" />

解 解如下所示，最左位(浅色字)被丢弃,0作为最右位(黑色背景中的白字)被插入。



原始数是 127，新的数是-2。因为上溢发生，所以结果非法。期望的答案是127x2=254，这个数不能用8位模式表示。



## 6.3 算术运算

算术运算包括加、减、乘、除，适用于整数和浮点数。

### 6.3.1 整数的算术运算

所有算术运算（如加、减、乘、除）均适用于整数。虽然整数的乘法（除法）能使用重复的加法（减法）来实现，但程序是低效的。对于乘法和除法有更高效的程序（如Booth算法），但这些超过了本书的范围，基于这个原因，我们这里只讨论整数的加法和减法。

**1. 二进制补码中的加减法**

我们首先讨论二进制补码表示的整数的加法和减法，这是因为它较容易。正如我们在第3章讨论的，整数通常是以二进制补码形式存储的。二进制补码表示法的一个优点是加法和减法间没有区别。当遇到减法时，计算机只简单地把它转变为加法，但要为第二个数求二进制的补。换言之：

\[ A - B \leftrightarrow A + (\overline{B} + 1) \]，这里的 \((\overline{B} + 1)\) 表示 \(B\) 的补码

这就意味着我们只需要讨论加法。二进制补码中的加法就像十进制中的加法一样：列与列相加，如果有进位，就加到下一列上。但是，最后一列的进位被舍弃。

记住，我们是一列接一列相加整数的。在每一列中，如果没有从前一列来的进位，那就有两位相加；或者如果有从前一列来的进位，那就有三位相加。

现在我们能显示两个用二进制补码格式表示的整数的加法或减法过程（图4-6）。注意我们使用 \((\overline{X} + 1)\) 表示 \(X\) 的补码，因为 \(\overline{X}\) 表示的 \(X\) 反码，所以这种记号非常常见。如果给一个整数的反码加1，就得到它的补码。

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250913142256364.png" alt="image-20250913142256364" style="zoom:67%;" />

<center>图6-6 二进制补码格式表示的整数的加法和减法</center>

过程如下：

1）如果运算是减法，我们取第二个整数的二进制补码，否则，转下一步。

2）两个整数相加。





**例 6-16**以二进制补码格式存储两个整数 $A$ 和 $B$，显示 $B$ 是如何被加到 $A$ 上的。

$A = (00010001)_2 \quad B = (00010110)_2$

解 运算是相加，$A$ 被加到 $B$ 上，结果存储在 $R$ 中。

| 进位  | 1                 |
| ----- | ----------------- |
| $A$   | 0 0 0 0 1 0 0 0 1 |
| + $B$ | 0 0 0 0 1 0 1 1 0 |
| $R$   | 0 0 0 1 0 0 1 1 1 |

用十进制检查结果：$(+17) + (+22) = (+39)$。

**例 6-17**以二进制补码格式存储两个整数 $A$ 和 $B$，显示 $B$ 是如何被加到 $A$ 上的。

$A = (00011000)_2 \quad B = (11101111)_2$

解 运算是相加，$A$ 被加到 $B$ 上，结果存储在 $R$ 中。注意，最后的进位被舍弃，因为存储器大小只有8位。

| 进位  | 1 1 1 1 1       |
| ----- | --------------- |
| $A$   | 0 0 0 1 1 0 0 0 |
| + $B$ | 1 1 1 0 1 1 1 1 |
| $R$   | 0 0 0 0 0 1 1 1 |

用十进制检查结果：$(+24) + (-17) = (+7)$。

**例 6-18**以二进制补码格式存储两个整数 $A$ 和 $B$，显示如何从 $A$ 中减去 $B$。

$A = (00011000)_2 \quad B = (11101111)_2$

解 运算是相减，$A$ 被加到 $(\overline{B} + 1)$ 上，结果存储在 $R$ 中。

| 进位                   | 1               |
| ---------------------- | --------------- |
| $A$                    | 0 0 0 1 1 0 0 0 |
| + $(\overline{B} + 1)$ | 0 0 0 1 0 0 0 1 |
| $R$                    | 0 0 1 0 1 0 0 1 |

用十进制检查结果：$(+24) - (-17) = (+41)$。

**例 6-19** 以二进制补码格式存储两个整数 $A$ 和 $B$，显示如何从 $A$ 中减去 $B$。

$A = (11011101)_2 \quad B = (00010100)_2$

解 运算是相减，$A$ 被加到 $(\overline{B} + 1)$ 上，结果存储在 $R$ 中。

| 进位                   | 1 1 1 1 1 1 1   |
| ---------------------- | --------------- |
| $A$                    | 1 1 0 1 1 1 0 1 |
| + $(\overline{B} + 1)$ | 1 1 1 0 1 1 0 0 |
| $R$                    | 1 1 0 0 1 0 0 1 |

用十进制检查结果：$(-35) + (+20) = (-55)$。注意，最后的进位被舍弃。

**例 6-20** 以二进制补码格式存储两个整数 $A$ 和 $B$，显示 $B$ 如何被加到 $A$ 上。

$A = (01111111)_2 \quad B = (00000011)_2$

解 运算是相加，$A$ 被加到 $B$ 上，结果存储在 $R$ 中。

| 进位  | 1 1 1 1 1 1 1   |
| ----- | --------------- |
| $A$   | 0 1 1 1 1 1 1 1 |
| + $B$ | 0 0 0 0 0 0 1 1 |
| $R$   | 1 0 0 0 0 0 1 0 |

我们期望的结果是127+3=130，但答案是-126。错误是由于上溢，因为期望的答案(+130)不在范围-128~+127 之间。
**当我们进行计算机中数字上的算术运算时，要记住每个数字和结果应该在分配的二进制位的定义范围之内。**

**2.符号加绝对值整数的加减法**

用符号加绝对值表示的整数的加法和减法看起来非常复杂。我们有4种不同的符号组合（两个符号，每个有两个值），对于减法有4种不同的条件。这就意味着我们要考虑8种不同的情况。



### 6.4.2 实数的算术运算

像加、减、乘和除这样的算术运算都能应用于用浮点数格式存储的实数上。两实数的乘法涉及两个用符号加绝对值表示的整数的乘法;两实数的除法涉及两个用符号加绝对值表示的整数的除法。



**关键术语**

本章介绍了以下关键术语：

AND operation (AND运算)	arithmetic operation (算术运算)

arithmetic shift operation (算术移位运算)	Boolean algebra (布尔代数)

circular shift operation (循环移位运算)	logical shift operation (逻辑移位运算)

mask (掩码)	NOT operation (NOT运算)	OR operation (OR运算)

truth table (真值表)	XOR operation (XOR运算)

> 这些术语涵盖了逻辑运算、算术运算、移位运算以及相关的数学概念。



**小结**

- 数据上的运算分成三大类：逻辑运算、移位运算和算术运算。逻辑运算是指那些应用于位模式单独位或两模式中相应的两位上的相同基本运算。移位运算移到模式中的位。算术运算涉及加、减、乘和除。
- 本章讨论了4种逻辑运算（NOT、AND、OR和XOR），它们能用在位层次或模式层次上。NOT运算符是一元运算符，而AND、OR和XOR是二元运算符。
- NOT运算符的唯一应用就是对整个模式求反；AND运算符的一个应用就是对位模式中指定的位进行复位（置为0）；OR运算符的一个应用就是对位模式中指定的位进行置位（置为1）；XOR运算符的一个应用就是对位模式中指定的位进行反转（求反）。
- 移位运算移到模式中的位：它们改变位的位置。我们能把移位运算分成两类：逻辑移位和算术移位。逻辑移位被应用于不表示为符号数的模式；算术移位假定位模式是二进制补码格式的符号整数。
- 像加、减、乘和除这样的所有的算术运算都能应用于整数。整数通常是存储在二进制补码格式中的。二进制补码格式表示的一个优点就是加法和减法间没有不同。当遇到减法时，计算机简单地把它改变为加法运算，然而此时对第二个数而言是求反运算。用符号加绝对值表示的整数的加法和减法看起来非常复杂，我们需要考虑8种情况。
- 像加、减、乘和除这样的所有的算术运算都能应用于用浮点数表示的实数，用浮点数表示的实数的加法和减法归纳为小数点对齐后的存储在符号加绝对值中的两整数的加法和减法。

> 以上内容总结了数据运算的基本分类及其特性，包括逻辑运算、移位运算和算术运算的具体应用和特点。



# 7 计算机组成概述

计算机系统主要由三大子系统构成：**中央处理单元（CPU）、主存储器以及输入/输出子系统**。它们协同工作，实现数据的存储、运算与传输。

## 中央处理单元（CPU）

CPU作为计算机的核心，负责执行对数据的各种操作。它包括三个关键部分：

- **算术逻辑单元（ALU）**：专门用于执行算术、移位及逻辑运算。
- **控制单元（CU）**：协调并管理CPU内部及与其他部件之间的操作流程。。
- **寄存器组**：一组高速临时存储单元，用于在运算过程中保存数据和指令。

## 主存储器

主存储器是计算机的数据仓库，每个存储单元都有唯一的地址标识。数据以“字”为基本单位进行读写，一个字由若干二进制位组成。根据功能，主存储器主要分为两类：

- **随机存取存储器（RAM）**：可读写的临时存储器，断电后数据丢失。
- **只读存储器（ROM）**：存放固定不变的系统程序或数据，通常在启动时使用。



## 输入/输出子系统

输入/输出（I/O）子系统使计算机能够与外界交互，同时实现数据的长期存储。I/O设备可分为两类：

- **非存储型设备**：如键盘、鼠标、显示器，用于人机交互。
- **存储型设备**：如硬盘、固态硬盘、光盘，提供数据的持久化保存。存储介质又可分为磁性和光学两类。



>   <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250105194428737.png" alt="image-20250105194428737" style="zoom: 50%;" />



## 子系统间的连接

CPU、主存储器和I/O子系统之间通过三类总线进行通信：

- **数据总线**：传输实际的数据。
- **地址总线**：指定数据的来源或目标地址。
- **控制总线**：传递控制信号，协调各组件工作。

I/O设备的寻址方式有两种：

- **I/O独立寻址**：I/O读写指令与内存读写指令不同。
- **存储器映射I/O**：将I/O控制器的寄存器映射为内存单元，通过统一的指令读写。



## 程序与指令执行

现代计算机通过**程序**来驱动工作。程序和数据都存放在内存中，CPU按照**机器周期**逐条取出并执行指令。一个简化的机器周期包含三个阶段：

1. **取指令**
2. **译码**
3. **执行**



## CPU与I/O设备同步

CPU与I/O设备之间存在速度差异，因此需要同步机制。常见的三种方式是：

- **程序控制I/O**：CPU主动等待设备完成。
- **中断驱动I/O**：设备完成任务后通知CPU，提高效率。
- **直接内存访问（DMA）**：数据在I/O设备和内存间直接传输，减少CPU干预。



## 现代计算机的优化技术

- **流水线技术**：将指令的取指、译码、执行等阶段并行处理，提高整体吞吐量。
- **并行处理**：通过多指令流、多数据流的并行执行来提升性能。
- **体系结构发展**：
  - **CISC（复杂指令集计算机）**：指令功能强大，便于编程，但执行效率可能较低。
  - **RISC（精简指令集计算机）**：指令简单、执行速度快，更适合流水线技术。





# 8 网络

计算机网络通常被划分为多个层次，每一层承担不同的功能，并通过特定的协议来实现这些功能。最常见的参考模型是 **OSI 七层模型** 和 **TCP/IP 四层模型**。下面介绍这两个模型及其主要协议。

## 8.1 OSI 七层模型

**网络协议** 是指在计算机网络中，为实现不同设备之间的通信而制定的一系列规则和约定。OSI 模型将通信过程分为七层，每层都有典型的协议：

1. **物理层（Physical Layer）**

​	负责通过物理媒介传输比特流，定义电气信号、传输介质等。

- 相关标准：

  - Ethernet (以太网)
  - DSL (数字用户线路)
  - 光纤传输协议（如Fiber Channel）
  - USB
  - Wi-Fi（也涉及到数据链路层，但物理层部分是无线通信标准）

2. **数据链路层（Data Link Layer）**

​	在物理链路上传输数据帧，保证基本的可靠性。

- 协议：
  - Ethernet（以太网）：用于局域网中的数据传输。
  - PPP（Point-to-Point Protocol，点对点协议）：用于点对点链路，常用于拨号上网。
  - Wi-Fi（无线局域网）：用于无线通信。
  - Frame Relay：一种用于连接多个局域网的协议，较早期常见。
  - HDLC（High-Level Data Link Control）：一种面向比特的协议，用于帧的交换。

3. **网络层（Network Layer）**

​	负责路由和寻址，实现主机到主机的传输。

- 协议：
  - **IP（Internet Protocol，互联网协议）**：主要用于在不同网络之间传输数据包，常见的版本有IPv4和IPv6。
  - **ICMP（Internet Control Message Protocol，互联网控制报文协议）**：用于发送控制消息，如ping命令。
  - **ARP（Address Resolution Protocol，地址解析协议）**：将IP地址解析为MAC地址。
  - **RARP（Reverse ARP）**：将MAC地址解析为IP地址（较少使用）。
  - **OSPF（Open Shortest Path First）**：一种动态路由协议，常用于大型网络中的路由选择。
  - **BGP（Border Gateway Protocol）**：用于互联网中的路由选择，支持跨自治系统的路由。

4. **传输层（Transport Layer）**

​	端到端传输，确保数据的顺序性与完整性。

- 协议：
  - **TCP（Transmission Control Protocol，传输控制协议）**：面向连接、可靠的传输协议，确保数据的顺序性和完整性。
  - **UDP（User Datagram Protocol，用户数据报协议）**：无连接、低延迟的传输协议，不保证可靠性。
  - **SCTP（Stream Control Transmission Protocol）**：面向消息的协议，结合了TCP和UDP的一些特点。

5. **会话层（Session Layer）**

​	建立、管理和终止会话。

- 协议：
  - **NetBIOS**：提供网络会话管理服务。
  - **RPC（Remote Procedure Call，远程过程调用）**：允许不同主机上的程序进行通信。
  - **SMB（Server Message Block）**：用于共享文件和打印机资源。
  - **TLS/SSL（Transport Layer Security / Secure Sockets Layer）**：用于在会话层加密数据传输。

6. **表示层（Presentation Layer）**

​	负责数据的格式化、加密和压缩。

- 协议：
  - **JPEG**、**GIF**、**PNG**：常见的图像文件格式。
  - **MPEG**、**MP3**：常见的音频和视频压缩格式。
  - **ASCII**、**EBCDIC**：字符编码格式。
  - **TLS/SSL**：可以在表示层加密数据。

7. **应用层（Application Layer）**

​	直接面向用户，提供各种应用服务。

- 协议：
  - **HTTP（Hypertext Transfer Protocol，超文本传输协议）**：用于网页浏览。
  - **HTTPS（Hypertext Transfer Protocol Secure）**：HTTP的安全版本，使用SSL/TLS进行加密。
  - **FTP（File Transfer Protocol，文件传输协议）**：用于文件传输。
  - **SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）**：用于发送电子邮件。
  - **POP3（Post Office Protocol 3，邮局协议3）**：用于接收电子邮件。
  - **IMAP（Internet Message Access Protocol，互联网邮件访问协议）**：比POP3更强大的电子邮件接收协议。
  - **DNS（Domain Name System，域名系统）**：用于将域名解析为IP地址。
  - **Telnet**：用于远程登录服务器。
  - **SSH（Secure Shell）**：用于远程登录，具备加密功能。
  - **DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）**：用于动态分配IP地址。

每一层都有其对应的协议和作用，它们共同合作使得网络通信得以顺畅进行。



## 8.2 TCP/IP 四层模型

相比 OSI，TCP/IP 模型更简化、实用，分为四层：

1. **链路层 (Link Layer)**
   - 协议：Ethernet、Wi-Fi 等
2. **网络层 (Internet Layer)**
   - 协议：IP、ICMP、ARP、RARP
3. **传输层 (Transport Layer)**
   - 协议：TCP、UDP
4. **应用层 (Application Layer)**
   - 协议：HTTP、FTP、SMTP、DNS 等（涵盖 OSI 的会话层和表示层功能）

**关键差异**：

- **OSI** 模型偏理论，将网络通信细分为七层；
- **TCP/IP** 模型更注重实践，采用四层结构，是现代互联网的主流。





以下列举相关的应用，便于记忆。如给出了DNS应用，SSH协议，python的urlopen抓取网页，C的socket编程等。



## 8.3 应用示例

**示例DNS应用**

域名解析错误可能由 DNS 污染（ISP 篡改、恶意软件、政府管制）导致。解决方法包括使用公共 DNS（Google 8.8.8.8 / Cloudflare 1.1.1.1）、修改 hosts 文件等。

![image-20250105190144627](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250105190144627.png)

从上图来看，raw.githubusercontent.com 的域名解析出现了问题。这可能是由于 DNS 污染(DNS hijacking导致的。DNS 污染是指某些网络服务提供商或恶意软件篡改了 DNS 解析结果，将用户引导到错误的 IP 地址。

DNS 污染通常发生在以下几种情况下:
1.ISP 篡改:一些互联网服务提供商(ISP)可能会故意篡改 DNS 解析结果，将用户重定向到广告页面或其他网站。
2.恶意软件:某些恶意软件会修改本地的 hosts 文件或系统设置，以达到类似的目的。
3.政府控制:在某些国家和地区，政府可能会实施 DNS 污染来阻止访问特定网站。

**如何解决 DNS 污染**
使用公共 DNS 服务器
你可以尝试使用公共 DNS 服务器，如 Google Public DNS (8.8.8.8和 8.8.4.4)或 Cloudflare DNS (1.1.1.1 和1.0.0.1)，这些服务器通常不会被篡改。
更改 DNS 设置: 可以通过系统偏好设置中的网络设置来更改 DNS 服务器地址。

修改本地 hosts 文件
如果你确定某个域名被污染，可以手动修改本地的 hosts 文件，将正确的IP 地址与域名绑定。



**示例SSH协议**

位于应用层，用于远程登录和命令执行，支持加密和身份认证，比 Telnet 更安全。可用于 SFTP/SCP 文件传输或端口隧道。



> **NIFE:**
>
> 校内疑似中毒机器IP，2024-10-15 17:12
>
> https://bbs.pku.edu.cn/v2/post-read.php?bid=668&threadid=18859011
>
> 今天实验室服务器被115.27.246.28和115.27.246.31尝试爆破ssh，望排查
>
> 
>
> **PKUCC（北京大学计算中心）:**
>
> 您好，这是官方扫描器。会定期检测弱密码。
>
> 
>
> **NIFE:**
>
> 每次被官方扫描器扫的时候我们的服务器的ssh都会拒绝所有新建立的连接，导致所有人都登录不到服务器，这个策略应该在ubuntu系统的哪个地方设置呢？
>
> 
>
> **JimmyChen:**
>
> 直接在ufw里把这俩ip屏蔽掉
>
> 
>
> **wwwxxx:**
>
> 防火墙加rule永封ip就可以了
>
> centos: firewall-cmd --permanent --zone=public --add-rich-rule 'rule family="ipv4" source address="x.x.x.x" drop'
>
> 此外防爆破用fail2ban比较好
>
> 个人建议
>
> 
>
> **TallestDwarf :**
>
> 我用fail2ban



**Python的urlopen**

Python 的 `urlopen`：`urllib.request.urlopen` 可基于 HTTP/HTTPS/FTP/file 等协议抓取资源。例如：爬取 Codeforces.com 题目列表并分类统计。

![image-20250105193346385](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250105193346385.png)



https://github.com/GMyhf/2019fall-cs101/blob/master/codeforces_v0.3.py

![image-20250105193916322](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250105193916322.png)

> `urllib.request.urlopen` 是 Python 标准库 `urllib` 中的一个函数，用于打开 URL。它能够处理多种协议，具体取决于所提供的 URL 方案（scheme）。以下是 `urllib.request.urlopen` 可能用到的主要网络协议：
>
> 1. **HTTP (HyperText Transfer Protocol)**: 这是最常用的协议之一，用于在 Web 浏览器和服务器之间传输网页。
>    - `urlopen` 使用 HTTP 来获取文本、图片等资源。
>
> 2. **HTTPS (HTTP Secure)**: 这是 HTTP 的安全版本，通过 SSL/TLS 加密通道进行数据传输，提供更高的安全性。当需要安全地传输敏感信息时，如登录凭据或信用卡信息，通常会使用 HTTPS。
>
> 3. **FTP (File Transfer Protocol)**: 尽管不如以前那么常见，但 `urlopen` 仍然支持 FTP 协议，用于从 FTP 服务器下载文件。请注意，对于某些类型的 FTP 操作，你可能需要使用更专门的库，如 `ftplib`。
>
> 4. **FILE**: 虽然不是真正的网络协议，但 `urlopen` 支持 file:// URLs 来访问本地文件系统中的文件。
>
> 5. **DATA**: 允许直接嵌入小量的数据到 URL 中，例如 data: URI 方案可以用来内联表示图像或其他内容。
>
> 6. **其他**: 理论上，如果安装了适当的处理器（handler），`urllib.request` 可以扩展以支持更多的协议。然而，在标准库中，上述提到的是最常使用的几种。
>
> 当调用 `urllib.request.urlopen` 函数时，它会根据提供的 URL 自动选择合适的协议，并执行相应的操作来获取资源。例如，如果 URL 开头是 "http://" 或 "https://", 它将使用 HTTP 或 HTTPS 协议；如果是 "ftp://", 则会使用 FTP 协议。对于每种协议，`urllib.request` 内部都有对应的协议处理器来处理细节。
>
> 



**C语言Socket编程**

- `tcp_echo_server.c` 和 `tcp_echo_client.c` 展示了基于 **TCP/IP** 的套接字通信。
- 使用 **TCP**（传输层）确保可靠传输，基于 **IP**（网络层）寻址，应用层逻辑为简单的“回显服务”。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[BUFFER_SIZE] = {0};
    int opt = 1;

    // 创建套接字
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // 设置套接字选项
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("setsockopt");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // 绑定套接字到指定的IP和端口
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // 开始监听
    if (listen(server_fd, 3) < 0) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d\n", PORT);

    // 接受连接
    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
        perror("accept");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // 读取客户端消息并回显
    while (read(new_socket, buffer, BUFFER_SIZE) > 0) {
        printf("Received: %s", buffer);
        send(new_socket, buffer, strlen(buffer), 0);
        memset(buffer, 0, BUFFER_SIZE);
    }

    // 关闭套接字
    close(new_socket);
    close(server_fd);

    return 0;
}

```



tcp_echo_client.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    struct sockaddr_in servaddr;
    int sock = 0;
    char buffer[BUFFER_SIZE] = {0};
    const char *hello = "Hello from client";

    // 创建套接字
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("\n Socket creation error \n");
        return -1;
    }

    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(PORT);

    // 将 IP 地址从字符串转换为二进制形式
    if (inet_pton(AF_INET, "127.0.0.1", &servaddr.sin_addr) <= 0) {
        printf("\nInvalid address/ Address not supported \n");
        return -1;
    }

    // 连接到服务器
    if (connect(sock, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
        printf("\nConnection Failed \n");
        return -1;
    }

    // 发送消息给服务器
    send(sock, hello, strlen(hello), 0);
    printf("Hello message sent\n");

    // 接收服务器回显的消息
    read(sock, buffer, BUFFER_SIZE);
    printf("Server echoed: %s\n", buffer);

    // 关闭套接字
    close(sock);

    return 0;
}

```

> 这两个程序（TCP Echo Server 和 TCP Echo Client）主要用到了以下网络协议：
>
> **传输层协议**
>
> 1. **TCP (Transmission Control Protocol)**:
>
>    - 这两个程序使用了面向连接的、可靠的传输层协议 TCP。在代码中，当创建套接字时指定了 SOCK_STREAM 类型，这表明将使用 TCP 协议来确保数据包按序到达，并提供错误检查和流量控制机制。
>
>      ```c
>      if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
>          perror("socket failed");
>          exit(EXIT_FAILURE);
>      }
>      ```
>
> **网络层协议**
>
> 2. **IP (Internet Protocol)**:
>
>    - IP 是互联网的核心协议，负责在网络间路由数据包。无论是在服务器端还是客户端，当你指定地址族为 AF_INET 时，你就是在使用 IPv4 地址格式进行通信。
>
>      ```c
>      address.sin_family = AF_INET;
>      address.sin_addr.s_addr = INADDR_ANY;
>      address.sin_port = htons(PORT);
>      ```
>
> **应用层协议**
>
> 3. **自定义应用层协议**:
>    - 在这个例子中，实际上并没有使用标准的应用层协议（如 HTTP、FTP 等）。相反，这是一个简单的回显（Echo）服务，它接收来自客户端的数据并将其原样返回给客户端。这种类型的交互可以被视为一种非常基础的应用层协议。
>
> **其他涉及的概念**
>
> - **端口**:
>   - 端口号用于标识计算机上的具体服务或应用程序。在这个例子中，服务器监听的是 8080 端口，而客户端连接到同一端口。
>
> - **套接字编程**:
>   - 套接字是应用程序与网络协议之间的接口。通过调用操作系统提供的套接字 API，程序可以发送和接收数据。
>
> 综上所述，这两个程序主要使用了 TCP 和 IP 协议，在此基础上实现了简单的回显服务。它们并不依赖于特定的标准应用层协议，而是实现了一个自定义的应用层逻辑来处理消息的接收和发送。



这两个C程序（tcp_echo_server.c, tcp_echo_client.c）编译后，运行，可以互通信息。如下图示

![image-20250105193430741](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250105193430741.png)



**示例Telnet 和 FTP 的替代方案**

Telnet 和 FTP（文件传输协议）的传统实现确实是以明文形式传输用户名和密码，这意味着在网络上传输的数据没有加密。这种做法存在严重的安全风险，因为任何能够截获网络流量的人都可以轻易读取到这些敏感信息。

随着网络安全意识的提高和技术的发展，这两种协议已经被认为不再安全，并逐渐被淘汰或被更安全的替代品所取代：

1. **Telnet**：已被SSH（Secure Shell）取代。SSH提供了加密的数据传输通道，不仅用于远程登录，还可以用于执行命令、文件传输等其他操作，同时保证了通信的安全性。

2. **FTP**：虽然传统FTP仍然存在，但推荐使用更安全的替代方案，比如：
   - **SFTP (SSH File Transfer Protocol)**：基于SSH协议，提供安全的文件传输。
   - **FTPS (FTP Secure)**：这是在FTP基础上添加了SSL/TLS加密层的版本，可以在数据传输过程中保护信息不被窃听或篡改。
   - **SCP (Secure Copy Protocol)**：也基于SSH，主要用于安全地复制文件。

尽管如此，在一些受限环境中，如某些内网环境或者老旧系统中，Telnet 和 FTP 可能仍然在使用。然而，在公共互联网上或对安全性有要求的场景下，它们几乎已经完全被更安全的协议所替代。对于新的项目或应用，强烈建议采用支持加密传输的现代协议以确保通信安全。



## 8.3 网络类别

是的，A 类、B 类、C 类网络的地址范围可以用 **二进制** 或 **十六进制** 表示，这有助于更清晰地理解它们的结构和主机地址的分配情况。

1. **A 类网络 (Class A)**

- **地址范围**：`1.0.0.0` 到 `126.255.255.255`

  - **二进制表示**：`00000001.00000000.00000000.00000000` 到 `01111110.11111111.11111111.11111111`
  - **十六进制表示**：`01.00.00.00` 到 `7E.FF.FF.FF`

- **默认子网掩码**：`255.0.0.0` 或 `/8`

  - **二进制掩码**：`11111111.00000000.00000000.00000000`
  - **十六进制掩码**：`FF.00.00.00`

- **主机部分大小**：A 类地址的主机部分占 **24 位**（32 位减去 8 位的网络部分）。

  - 可分配的主机地址数：

    ```
    2^24 - 2 = 16,777,214
    ```

    - 去掉网络地址和广播地址，剩余可分配给主机的地址数为 **16,777,214** 个。

2. **B 类网络 (Class B)**

- **地址范围**：`128.0.0.0` 到 `191.255.255.255`

  - **二进制表示**：`10000000.00000000.00000000.00000000` 到 `10111111.11111111.11111111.11111111`
  - **十六进制表示**：`80.00.00.00` 到 `BF.FF.FF.FF`

- **默认子网掩码**：`255.255.0.0` 或 `/16`

  - **二进制掩码**：`11111111.11111111.00000000.00000000`
  - **十六进制掩码**：`FF.FF.00.00`

- **主机部分大小**：B 类地址的主机部分占 **16 位**（32 位减去 16 位的网络部分）。

  - 可分配的主机地址数：

    ```
    2^16 - 2 = 65,534
    ```

    - 去掉网络地址和广播地址，剩余可分配给主机的地址数为 **65,534** 个。

3. **C 类网络 (Class C)**

- **地址范围**：`192.0.0.0` 到 `223.255.255.255`

  - **二进制表示**：`11000000.00000000.00000000.00000000` 到 `11011111.11111111.11111111.11111111`
  - **十六进制表示**：`C0.00.00.00` 到 `DF.FF.FF.FF`

- **默认子网掩码**：`255.255.255.0` 或 `/24`

  - **二进制掩码**：`11111111.11111111.11111111.00000000`
  - **十六进制掩码**：`FF.FF.FF.00`

- **主机部分大小**：C 类地址的主机部分占 **8 位**（32 位减去 24 位的网络部分）。

  - 可分配的主机地址数：

    ```
    2^8 - 2 = 254
    ```

    - 去掉网络地址和广播地址，剩余可分配给主机的地址数为 **254** 个。

总结：

| 网络类别 | 地址范围（十进制）               | 地址范围（二进制）                                           | 默认子网掩码             | 可分配的主机数 |
| -------- | -------------------------------- | ------------------------------------------------------------ | ------------------------ | -------------- |
| **A 类** | `1.0.0.0` 到 `126.255.255.255`   | `00000001.00000000.00000000.00000000` 到 `01111110.11111111.11111111.11111111` | `255.0.0.0` 或 `/8`      | 16,777,214     |
| **B 类** | `128.0.0.0` 到 `191.255.255.255` | `10000000.00000000.00000000.00000000` 到 `10111111.11111111.11111111.11111111` | `255.255.0.0` 或 `/16`   | 65,534         |
| **C 类** | `192.0.0.0` 到 `223.255.255.255` | `11000000.00000000.00000000.00000000` 到 `11011111.11111111.11111111.11111111` | `255.255.255.0` 或 `/24` | 254            |

注意：

- 每个网络类别的地址范围是基于 IP 地址的 **首字节** 来区分的。
- 主机可分配的地址数总是减去 2 个，因为网络地址和广播地址不能分配给主机。



> 网络中 01111111.11111111.11111111.11111111不分配？
>
> 在网络中，二进制表示的IP地址 `01111111.11111111.11111111.11111111` 转换成十进制是 `127.255.255.255`。这个地址属于127.0.0.0/8地址段，这是专门保留用于环回（loopback）功能的地址段。
>
> 环回地址主要用于网络软件测试以及本地机进程间通信，并不分配给任何物理网络接口，也不会路由到远程网络。所有发往环回地址的数据包都会被操作系统截获，并在内部循环回来，如同发送到了“自己”一样。
>
> 因此，`127.255.255.255` 不会分配给任何实际的网络设备或在网络上进行传输。实际上，整个127.0.0.0/8网段都是如此，不过最常用的环回地址是 `127.0.0.1`。



> 每类网络去掉网络地址和广播地址？
>
> 在IP地址分类中，每类网络（A、B、C、D、E）都有特定的范围，并且每个网络内部有两个特殊的地址不分配给主机：一个是网络地址（用于标识该网络本身），另一个是广播地址（用于向该网络中的所有主机发送信息）。下面是对于IPv4地址中A、B、C三类网络去掉网络地址和广播地址后可用主机数量的简要说明：
>
> - **A类网络**：
>   - 地址范围：0.0.0.0 到 127.255.255.255
>   - 网络地址：最左边的一位是0，因此网络地址是该范围内最小的地址。
>   - 广播地址：该网段内的最大地址。
>   - 可用主机数：2^24 - 2 = 16,777,214个主机
>
> - **B类网络**：
>   - 地址范围：128.0.0.0 到 191.255.255.255
>   - 网络地址：前两位是10，网络地址是该范围内最小的地址。
>   - 广播地址：该网段内的最大地址。
>   - 可用主机数：2^16 - 2 = 65,534个主机
>
> - **C类网络**：
>   - 地址范围：192.0.0.0 到 223.255.255.255
>   - 网络地址：前三位是110，网络地址是该范围内最小的地址。
>   - 广播地址：该网段内的最大地址。
>   - 可用主机数：2^8 - 2 = 254个主机
>
> 请注意，上述计算基于传统的分类网络。然而，在现代网络中，可变长子网掩码（VLSM）和无类别域间路由（CIDR）被广泛使用，这使得网络划分更加灵活，不再严格遵循传统分类。因此，实际可用的主机数量可能会因具体的子网掩码而有所不同。
>
> 另外，D类和E类地址不用于常规的主机通信，D类地址用于多播，E类地址保留供将来或实验使用。



> A类首位为0，对应1到126；
> B类前两位10，对应128到191；
> C类前三位110，对应192到223；
> D类前四位1110，对应224到239；
> E类前5位为11110，对应240到255
>
> “可分配的地址”，指的是同一个网段下的可分配主机数量？
> 比如A类掩码255.0.0.0，那某个网段下就可以有2^24-2个主机，这是因为后24位全0和全1都不可分配，全1用来广播，全0应该直接对应这个网段
>
> B类可用网络数是`2^14=16384`，可用主机数是`2^16-2=65534`
>
> 128.0到191.255共16384个B类网段



# 附录

## A 以只读方式打开UTF-8 编码的文件

本程序演示如何使用 Python 以只读模式打开一个 UTF-8 编码的文件。程序支持通过**绝对路径**或**相对路径**访问文件，适用于多种目录结构。

> **说明**：示例在 macOS 系统下运行。与 Windows 不同，macOS 使用正斜杠 `/` 作为路径分隔符。代码中出现的双斜杠 `//` 是为了兼容某些情况下路径转义的需求（尽管在大多数现代 Python 版本中单斜杠即可正常工作），但通常推荐使用单斜杠或原生路径处理方式（如 `os.path` 或 `pathlib`）。

**示例数据准备**

首先，在 `program/data/` 目录下创建一个 CSV 文件：

```bash
echo "北京大学PKU" > data/math.csv
```

该命令将文本“北京大学PKU”写入 `data/math.csv` 文件中。

**Python 读取程序**

```python
import csv

# 可选路径配置（取消注释任一行即可）
# file_path = "data/math.csv"                              # 相对路径（推荐）
# file_path = "data//math.csv"                             # 双斜杠路径（兼容性写法）
# file_path = '/Users/hfyan/Code/5.1/program/data/math.csv' # 绝对路径

file_path = "data/math.csv"  # 默认使用相对路径

try:
    with open(file_path, 'r', encoding='utf-8') as fo:
        reader = csv.reader(fo)
        for row in reader:
            print(row)

except FileNotFoundError:
    print(f"错误：未找到文件，请检查路径是否正确：{file_path}")
except Exception as e:
    print(f"发生未知错误：{e}")
```

**运行结果**

执行命令：

```bash
python read_file.py
```

输出结果为：

```
['北京大学PKU']
```

这表明程序成功读取了 UTF-8 编码的中文内容。

> 使用 `with` 语句打开文件，确保资源自动释放。
>
> 指定 `encoding='utf-8'` 是关键，尤其在处理包含中文等非 ASCII 字符的文件时，防止出现编码错误。
>
> 更多文件操作方法可参考：[Python3 文件方法 | 菜鸟教程](https://www.runoob.com/python3/python3-file-methods.html)

